<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vari: vari</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">vari
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">vari </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_README"></a> </p><div align="center"></div><div align="center">Variadic library</div><div align="center"><hr  />
</div><div align="center"><a href="/example.cpp">Example</a> - <a href="https://koniarik.github.io/vari/">Documentation</a></div><div align="center"></div><p >C++ has <code>std::variant&lt;Ts...&gt;</code> as a tagged union, but we find it lacking in capabilities and just plain ... bad.</p>
<p ><code>vari</code> introduces enhanced alternatives with a more advanced API, flexible type conversions, and improved ways to define variadic types.</p>
<p >The library introduces four basic types:</p><ul>
<li><code>vptr&lt;Ts...&gt;</code> - A pointer to any type out of <code>Ts...</code>, which can be null.</li>
<li><code>vref&lt;Ts...&gt;</code> - A reference to any type out of <code>Ts...</code>.</li>
<li><code>uvptr&lt;Ts...&gt;</code> - A unique (owning) pointer to any type out of <code>Ts...</code>, which can be null.</li>
<li><code>uvref&lt;Ts...&gt;</code> - A unique (owning) reference to any type out of <code>Ts...</code>.</li>
</ul>
<hr  />
<ul>
<li>vref and vptr</li>
<li>uvptr and uvref</li>
<li>Access API<ul>
<li>Visit</li>
<li>Take</li>
</ul>
</li>
<li>Sub-typing</li>
<li>Concepts checks</li>
<li>Single-type extension</li>
<li>Type-sets</li>
<li>Lvalue conversion from unique</li>
<li>Const</li>
<li>Typelist compatibility</li>
<li>Dispatch</li>
<li>Credits</li>
</ul>
<h2><a class="anchor" id="autotoc_md2"></a>
vref and vptr</h2>
<p ><code>vref</code> and <code>vptr</code> are used to point to any type from a specified list of types. The <code>vref</code> always points to a valid object, whereas <code>vptr</code> can be null.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> foo = [&amp;](vref&lt;int, float&gt; v){</div>
<div class="line">    v.visit([&amp;](<span class="keywordtype">int</span>&amp; i)  { std::cout &lt;&lt; <span class="stringliteral">&quot;this is int: &quot;</span>   &lt;&lt; i &lt;&lt; std::endl;},</div>
<div class="line">            [&amp;](<span class="keywordtype">float</span>&amp; f){ std::cout &lt;&lt; <span class="stringliteral">&quot;this is float: &quot;</span> &lt;&lt; f &lt;&lt; std::endl;});</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line">foo(i); <span class="comment">// &lt;&lt; vref&lt;int,float&gt; points to `i`</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> f;</div>
<div class="line">foo(f); <span class="comment">// &lt;&lt; vref&lt;int, float&gt; points to `f`</span></div>
</div><!-- fragment --><p >Here <code>foo</code> accepts a <code>vref</code> that references either an <code>int</code> or a <code>float</code>.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
uvptr and uvref</h2>
<p >The <code>u</code>-prefixed variants (<code>uvptr</code> and <code>uvref</code>) imply unique ownership, which means they manage the lifetimes of objects.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>a_t{};</div>
<div class="line"><span class="keyword">struct </span>b_t{};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#a3be05c6f854dc1b903a2a85e244bbdc5">vari::uvptr&lt;a_t, b_t&gt;</a> p;</div>
<div class="ttc" id="anamespacevari_html_a3be05c6f854dc1b903a2a85e244bbdc5"><div class="ttname"><a href="namespacevari.html#a3be05c6f854dc1b903a2a85e244bbdc5">vari::uvptr</a></div><div class="ttdeci">_define_variadic&lt; _uvptr, typelist&lt; Ts... &gt;, def_del &gt; uvptr</div><div class="ttdef"><b>Definition:</b> uvptr.h:218</div></div>
</div><!-- fragment --><p >Similar to <code>std::make_unique</code>, we provide a function <code>uwrap</code> for construction of unique variants:</p>
<div class="fragment"><div class="line">uvref&lt;std::string, int&gt; p = uwrap(std::string{<span class="stringliteral">&quot;wololo&quot;</span>});</div>
</div><!-- fragment --><p >Here <code>uwrap</code> creates <code>uvref&lt;std::string&gt;</code> which gets converted into <code>uvref&lt;std::string,int&gt;</code> due to implicit conversion.</p>
<p >WARNING: <code>uvref</code> is movable, and when moved from, it enters a null state. It shall not be used in this state except for reassignment.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Access API</h2>
<p >To access the underlying type, <code>vptr</code>, <code>vref</code>, <code>uvptr</code>, and <code>uvref</code> use the <code>visit</code> method as the primary interface. The <code>u</code> variants also have <code>take</code> to transfer ownership.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Visit</h3>
<p >The <code>visit</code> method works similarly to <code>std::visit</code> but allows multiple callables:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> foo = [&amp;]( <a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt; std::vector&lt; std::string &gt;</a>, std::list&lt; std::string &gt; &gt; r ) -&gt; std::string&amp;</div>
<div class="line">{</div>
<div class="line">        std::string&amp; front = r.visit(</div>
<div class="line">            [&amp;]( std::vector&lt; std::string &gt;&amp; v ) -&gt; std::string&amp; {</div>
<div class="line">                    <span class="keywordflow">return</span> v.front();</div>
<div class="line">            },</div>
<div class="line">            [&amp;]( std::list&lt; std::string &gt;&amp; l ) -&gt; std::string&amp; {</div>
<div class="line">                    <span class="keywordflow">return</span> l.front();</div>
<div class="line">            } );</div>
<div class="line">        <span class="keywordflow">return</span> front;</div>
<div class="line">};</div>
<div class="ttc" id="anamespacevari_html_a0b711b10138e06f9d5b455ff55c663d0"><div class="ttname"><a href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref</a></div><div class="ttdeci">_define_variadic&lt; _vref, typelist&lt; Ts... &gt; &gt; vref</div><div class="ttdef"><b>Definition:</b> vref.h:146</div></div>
</div><!-- fragment --><p >For pointers, there must be a callable that accepting <code><a class="el" href="structvari_1_1empty__t.html">vari::empty_t</a></code> to handle cases where the pointer is null:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr&lt;int, std::string&gt;</a> r = <span class="keyword">nullptr</span>;</div>
<div class="line"> </div>
<div class="line">r.visit([&amp;](<a class="code hl_struct" href="structvari_1_1empty__t.html">vari::empty_t</a>){},</div>
<div class="line">        [&amp;](<span class="keywordtype">int</span>&amp;){},</div>
<div class="line">        [&amp;](std::string&amp;){});</div>
<div class="ttc" id="anamespacevari_html_a50c11a69a9d782e1ccaa6ebd7be73725"><div class="ttname"><a href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr</a></div><div class="ttdeci">_define_variadic&lt; _vptr, typelist&lt; Ts... &gt; &gt; vptr</div><div class="ttdef"><b>Definition:</b> vptr.h:172</div></div>
<div class="ttc" id="astructvari_1_1empty__t_html"><div class="ttname"><a href="structvari_1_1empty__t.html">vari::empty_t</a></div><div class="ttdef"><b>Definition:</b> util.h:33</div></div>
</div><!-- fragment --><p >Variadic references can be constructed with references to any of the possible types:</p>
<div class="fragment"><div class="line">std::string a;</div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;int, std::string&gt;</a> r = a;</div>
</div><!-- fragment --><p >This also allows us to combine it with <code>visit</code>, where the callable can handle multiple types:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacevari.html#a3be05c6f854dc1b903a2a85e244bbdc5">vari::uvptr&lt;int, std::string&gt;</a> r;</div>
<div class="line"> </div>
<div class="line">r.visit([&amp;](<a class="code hl_struct" href="structvari_1_1empty__t.html">vari::empty_t</a>){},</div>
<div class="line">        [&amp;](<a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;int, std::string&gt;</a>){});</div>
</div><!-- fragment --><p >Or we can mix both approaches:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacevari.html#a3be05c6f854dc1b903a2a85e244bbdc5">vari::uvptr&lt;int, float, std::string&gt;</a> r = <span class="keyword">nullptr</span>;</div>
<div class="line"> </div>
<div class="line">r.visit([&amp;](<a class="code hl_struct" href="structvari_1_1empty__t.html">vari::empty_t</a>){},</div>
<div class="line">        [&amp;](std::string&amp;){},</div>
<div class="line">        [&amp;](<a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;int, float&gt;</a>){});</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md6"></a>
Take</h3>
<p ><code>uvref</code> and <code>uvptr</code> retain ownership of referenced items, the <code>take</code> method is used to transfer ownership:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> foo = [&amp;](<a class="code hl_typedef" href="namespacevari.html#a2388c0eb42106efee2d8ed10243b69a0">vari::uvref&lt;int, std::string&gt;</a> r)</div>
<div class="line">{</div>
<div class="line">    std::move(r).take([&amp;](<a class="code hl_typedef" href="namespacevari.html#a2388c0eb42106efee2d8ed10243b69a0">vari::uvref&lt;int&gt;</a>){},</div>
<div class="line">                      [&amp;](<a class="code hl_typedef" href="namespacevari.html#a2388c0eb42106efee2d8ed10243b69a0">vari::uvref&lt;std::string&gt;</a>){});</div>
<div class="line">};</div>
<div class="ttc" id="anamespacevari_html_a2388c0eb42106efee2d8ed10243b69a0"><div class="ttname"><a href="namespacevari.html#a2388c0eb42106efee2d8ed10243b69a0">vari::uvref</a></div><div class="ttdeci">_define_variadic&lt; _uvref, typelist&lt; Ts... &gt;, def_del &gt; uvref</div><div class="ttdef"><b>Definition:</b> uvref.h:207</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7"></a>
Sub-typing</h2>
<p >All variadic types support sub-typing, meaning any variadic type can be converted into a type that represents a superset of its types:</p>
<div class="fragment"><div class="line">std::string a;</div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;std::string&gt;</a> p{a};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// allowed as {int, std::string} is superset of {std::string}</span></div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;int, std::string&gt;</a> p2 = p;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// not allowed, as {int} is not superset of {int, std::string}</span></div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;int, std::string&gt;</a> p3 = p2;</div>
</div><!-- fragment --><p >This feature also works seamlessly with <code>take</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>a_t{};</div>
<div class="line"><span class="keyword">struct </span>b_t{};</div>
<div class="line"><span class="keyword">struct </span>c_t{};</div>
<div class="line"><span class="keyword">struct </span>d_t{};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> foo = [&amp;](<a class="code hl_typedef" href="namespacevari.html#a3be05c6f854dc1b903a2a85e244bbdc5">vari::uvptr&lt;a_t, b_t, c_t, d_t&gt;</a> p)</div>
<div class="line">{</div>
<div class="line">    std::move(p).take([&amp;](<a class="code hl_struct" href="structvari_1_1empty__t.html">vari::empty_t</a>){},</div>
<div class="line">                      [&amp;](<a class="code hl_typedef" href="namespacevari.html#a2388c0eb42106efee2d8ed10243b69a0">vari::uvref&lt;a_t, b_t&gt;</a>){},</div>
<div class="line">                      [&amp;](<a class="code hl_typedef" href="namespacevari.html#a2388c0eb42106efee2d8ed10243b69a0">vari::uvref&lt;c_t, d_t&gt;</a>){});</div>
<div class="line">};</div>
</div><!-- fragment --><p >In this example, <code>p</code> represents a set of four types. The <code>take</code> method allows us to split this set into four unique references, each representing one type. Sub-typing enables us to combine these references into two subsets, each consisting of two types.</p>
<p >Note: As a side-effect of this, <code>vptr&lt;a_t, b_t&gt;</code> is naturally convertible to <code>vptr&lt;b_t, a_t&gt;</code></p>
<h2><a class="anchor" id="autotoc_md8"></a>
Concepts checks</h2>
<p >Access methods are subject to sanity checks on the set of provided callbacks: for each type in the set, exactly one callback must be callable.</p>
<p >For instance, the following code would fail to compile due to a concept check violation:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> foo = [&amp;](<a class="code hl_typedef" href="namespacevari.html#a2388c0eb42106efee2d8ed10243b69a0">vari::uvref&lt;int, std::string&gt;</a> r)</div>
<div class="line">{</div>
<div class="line">    r.visit([&amp;](<span class="keywordtype">int</span>&amp;){},</div>
<div class="line">            [&amp;](<span class="keywordtype">int</span>&amp;){}, <span class="comment">// error: second overload matching int</span></div>
<div class="line">            [&amp;](std::string&amp;){});</div>
<div class="line">};</div>
</div><!-- fragment --><p >Note that this rule also applies to templated arguments:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> foo = [&amp;](<a class="code hl_typedef" href="namespacevari.html#a2388c0eb42106efee2d8ed10243b69a0">vari::uvref&lt;int, std::string&gt;</a> r)</div>
<div class="line">{</div>
<div class="line">    r.visit([&amp;](<span class="keywordtype">int</span>&amp;){},</div>
<div class="line">            [&amp;](<span class="keyword">auto</span>&amp;){}, <span class="comment">// error: second overload matching int</span></div>
<div class="line">            [&amp;](std::string&amp;){});</div>
<div class="line">};</div>
</div><!-- fragment --><p >Another important check: each callable must be compatible with at least one type in the set.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> i = 42;</div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;int, float&gt;</a> v = i;</div>
<div class="line">v.visit([&amp;](<span class="keywordtype">int</span>&amp;){},</div>
<div class="line">        [&amp;](std::string&amp;){}, <span class="comment">// error: callable does not match any type</span></div>
<div class="line">        [&amp;](<span class="keywordtype">float</span>&amp;){});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
Single-type extension</h2>
<p >To make working with variants more convenient, all variadic types allow direct access to the pointed-to type if there is only a single type in the type list:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>boo_t{</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line">boo_t b;</div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr&lt;boo_t&gt;</a> p = &amp;b;</div>
<div class="line"> </div>
<div class="line">p-&gt;val = 42;</div>
</div><!-- fragment --><p >This feature makes <code>vref</code> a useful replacement for raw references in structures:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_type{</div>
<div class="line">    vref&lt;std::string&gt; str;</div>
<div class="line">};</div>
</div><!-- fragment --><p> If you used <code>std::string&amp; str</code>, it would prevent the ability to reassign the reference within the structure. <code>vref</code>, however, does not have this limitation, allowing reassignment.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Type-sets</h2>
<p >For added convenience and functionality, the template argument list of variadic types can flatten and filter types for uniqueness.</p>
<p >Given the following type sets:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>set_a = <a class="code hl_struct" href="structvari_1_1typelist.html">vari::typelist&lt;int, std::string&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>set_b = <a class="code hl_struct" href="structvari_1_1typelist.html">vari::typelist&lt;float, int&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>set_s = <a class="code hl_struct" href="structvari_1_1typelist.html">vari::typelist&lt;set_a, set_b, std::string&gt;</a>;</div>
<div class="ttc" id="astructvari_1_1typelist_html"><div class="ttname"><a href="structvari_1_1typelist.html">vari::typelist</a></div><div class="ttdef"><b>Definition:</b> typelist.h:32</div></div>
</div><!-- fragment --><p >The pointer <code>vptr&lt;set_s&gt;</code> resolves to the equivalent of <code>vptr&lt;int, std::string, float&gt;</code>. The flattening and filtering mechanism only applies to <code><a class="el" href="structvari_1_1typelist.html">vari::typelist</a></code>. For example, <code>void&lt;std::tuple&lt;a_t,b_t&gt;&gt;</code> would not be automatically resolved to a different form.</p>
<p >Why is this useful? It allows expressing complex data structures more effectively. Moreover, the typelists also interact well with sub-typing:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>simple_types = <a class="code hl_struct" href="structvari_1_1typelist.html">vari::typelist&lt;std::string, int, bool&gt;</a>;</div>
<div class="line"><span class="keyword">struct </span>array_t{};</div>
<div class="line"><span class="keyword">struct </span>object_t{};</div>
<div class="line"><span class="keyword">using </span>complex_types = <a class="code hl_struct" href="structvari_1_1typelist.html">vari::typelist&lt;array_t, object_t&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>json_types = <a class="code hl_struct" href="structvari_1_1typelist.html">vari::typelist&lt;simple_types, complex_types&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> simple_to_str = [&amp;](<a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;simple_types&gt;</a> p) { <span class="keywordflow">return</span> std::string{}; };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> to_str = [&amp;](<a class="code hl_typedef" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr&lt;json_types&gt;</a> p)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>R = std::string;</div>
<div class="line">    <span class="keywordflow">return</span> p.visit([&amp;](<a class="code hl_struct" href="structvari_1_1empty__t.html">vari::empty_t</a>) -&gt; R { <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>; },</div>
<div class="line">                   [&amp;](<a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;simple_types&gt;</a> pp) -&gt; R { <span class="keywordflow">return</span> simple_to_str(pp); },</div>
<div class="line">                   [&amp;](array_t&amp; pp) -&gt; R { <span class="comment">/* impl */</span> },</div>
<div class="line">                   [&amp;](object_t&amp; pp) -&gt; R { <span class="comment">/* impl */</span> });</div>
<div class="line">};</div>
</div><!-- fragment --><p >This approach makes it easier to handle complex type hierarchies while preserving the flexibility and power of variadic types.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Lvalue conversion from unique</h2>
<p >For added convenience, the library allows converting <code>uvptr</code> and <code>uvref</code> to their non-unique counterparts, but only if the expression is an lvalue reference:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> foo = [&amp;](<a class="code hl_typedef" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr&lt;int, std::string&gt;</a>){};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#a3be05c6f854dc1b903a2a85e244bbdc5">vari::uvptr&lt;int&gt;</a> p;</div>
<div class="line">foo(p); <span class="comment">// allowed, `p` is lvalue</span></div>
<div class="line"> </div>
<div class="line">foo(<a class="code hl_typedef" href="namespacevari.html#a3be05c6f854dc1b903a2a85e244bbdc5">vari::uvptr&lt;std::string&gt;</a>{}); <span class="comment">// forbidden, rvalue used</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md12"></a>
Const</h2>
<p >All variadic types support conversion from non-const version to const version:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> foo = [&amp;](<a class="code hl_typedef" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr&lt;int const, std::string const&gt;</a>){};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr&lt;int, std::string&gt;</a> p;</div>
<div class="line">foo(p);</div>
</div><!-- fragment --><p ><code>const</code> is also properly propagated during typelist operations:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>set_a = <a class="code hl_struct" href="structvari_1_1typelist.html">vari::typelist&lt;int, std::string&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>vp_a = <a class="code hl_typedef" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr&lt;const set_a&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>vp_b = <a class="code hl_typedef" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr&lt;const int, const std::string&gt;</a>;</div>
</div><!-- fragment --><p >Both types <code>vp_a</code> and <code>vp_b</code> are compatible.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Typelist compatibility</h2>
<p >Library can be extended by using other types than just <code><a class="el" href="structvari_1_1typelist.html">vari::typelist</a></code> to represent set of types.</p>
<p >Whenever type is typelist is determined by <code><a class="el" href="structvari_1_1typelist__traits.html">vari::typelist_traits</a>&lt;T&gt;</code>. In case <code><a class="el" href="structvari_1_1typelist__traits.html">vari::typelist_traits</a>&lt;T&gt;:::is_compatible</code> evaluates to <code>true</code>, library considers <code>T</code> to be typelist-like type.</p>
<p >In such a case, <code><a class="el" href="structvari_1_1typelist__traits.html">vari::typelist_traits</a>&lt;T&gt;::types</code> should be a type which by itself is vari-compatible typelist. Transtively, this should eventually resolve into <code><a class="el" href="structvari_1_1typelist.html">vari::typelist</a></code> itself which is used by the library directly.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Dispatch</h2>
<p >We also ship free function <code>dispatch</code> for mapping a runtime value into compile-time value. It uses all the safety checks of <code>visit</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// factory used by the library to create instances of types</span></div>
<div class="line"><span class="keyword">auto</span> factory = [&amp;]&lt;<a class="code hl_typedef" href="namespacevari.html#a4c4b642a120de6f97cef24c8b60fb2ce">vari::index_type</a> i&gt;{</div>
<div class="line">    <span class="keywordflow">return</span> std::integral_constant&lt;std::size_t, i&gt;{};</div>
<div class="line">};</div>
<div class="line"><span class="comment">// runtime index</span></div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#a4c4b642a120de6f97cef24c8b60fb2ce">vari::index_type</a> v = 2;</div>
<div class="line">vari::dispatch&lt;3&gt;(</div>
<div class="line">    v,</div>
<div class="line">    factory,</div>
<div class="line">    [&amp;](std::integral_constant&lt;std::size_t, 0&gt;){</div>
<div class="line">        <span class="comment">// `j` matches value of `v`</span></div>
<div class="line">    },</div>
<div class="line">    [&amp;](std::integral_constant&lt;std::size_t, 1&gt;){</div>
<div class="line">        <span class="comment">// `j` matches value of `v`</span></div>
<div class="line">    },</div>
<div class="line">    [&amp;](std::integral_constant&lt;std::size_t, 2&gt;){</div>
<div class="line">        <span class="comment">// `j` matches value of `v`</span></div>
<div class="line">    });</div>
<div class="ttc" id="anamespacevari_html_a4c4b642a120de6f97cef24c8b60fb2ce"><div class="ttname"><a href="namespacevari.html#a4c4b642a120de6f97cef24c8b60fb2ce">vari::index_type</a></div><div class="ttdeci">uint32_t index_type</div><div class="ttdef"><b>Definition:</b> util.h:169</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
Credits</h2>
<p >Credits for the idea for this should go to <code>avakar</code>, live long and prosper. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
