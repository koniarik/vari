<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vari: Variadic library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">vari
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Variadic library </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_README"></a> Variadic pointers, references for C++20.</p>
<p ><code>std::variant&lt;Ts...&gt;</code> is C++20s form of tagged union which stores types by value. This library introduces an alternative that stores items allocated and extends the tagged union concept with type-sets, sub-typing and other forms of API access, making it more pleasant to use.</p>
<p >Library provides 4 templated types as an alternative to variant:</p><ul>
<li><code>vref&lt;Ts...&gt;</code> - reference to any type out of <code>Ts...</code></li>
<li><code>vptr&lt;Ts...&gt;</code> - pointer to any type out of <code>Ts...</code> (aka: nullable reference)</li>
<li><code>uvref&lt;Ts...&gt;</code> - owning reference to any type out of <code>Ts...</code></li>
<li><code>uvptr&lt;Ts...&gt;</code> - owning pointer to any type out of <code>Ts...</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md1"></a>
From std::variant to vptr or vref</h1>
<p >Let's say that we want a function, that can accept one of two types, how to model it with <code>std::variant</code>?</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>a_t{};</div>
<div class="line"><span class="keyword">struct </span>b_t{};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo(std::variant&lt;a_t*, b_t*&gt;);</div>
<div class="line"> </div>
<div class="line">a_t a;</div>
<div class="line">foo(&amp;a);</div>
</div><!-- fragment --><p ><code>vptr</code> usage is as simple: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_typedef" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr&lt;a_t, b_t&gt;</a>);</div>
<div class="line"> </div>
<div class="line">a_t a;</div>
<div class="line">foo(a);</div>
<div class="ttc" id="anamespacevari_html_a50c11a69a9d782e1ccaa6ebd7be73725"><div class="ttname"><a href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr</a></div><div class="ttdeci">_define_variadic&lt; _vptr, typelist&lt; Ts... &gt; &gt; vptr</div><div class="ttdef"><b>Definition:</b> vptr.h:141</div></div>
</div><!-- fragment --><p >But, what if we want to express that the pointer can never be null? With variant we can use <code>std::variant&lt;std::reference_wrapper&lt;a_t&gt;, std::reference_wrapper&lt;b_t&gt;&gt;</code> but that is not elegant at all. Here, <code>vref</code> comes to the rescue: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;a_t, b_t&gt;</a>);</div>
<div class="ttc" id="anamespacevari_html_a0b711b10138e06f9d5b455ff55c663d0"><div class="ttname"><a href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref</a></div><div class="ttdeci">_define_variadic&lt; _vref, typelist&lt; Ts... &gt; &gt; vref</div><div class="ttdef"><b>Definition:</b> vref.h:102</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md2"></a>
uvptr and uvref</h1>
<p ><code>u</code> prefixed variants imply ownership (unique), this way we can use them to manage lifetimes of objects - in same way as <code>std::variant</code> does.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>a_t;</div>
<div class="line"><span class="keyword">struct </span>b_t;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#ad82d68f165b27cedcbdf385779eacb69">vari::uvptr&lt;a_t, b_t&gt;</a> p;</div>
<div class="ttc" id="anamespacevari_html_ad82d68f165b27cedcbdf385779eacb69"><div class="ttname"><a href="namespacevari.html#ad82d68f165b27cedcbdf385779eacb69">vari::uvptr</a></div><div class="ttdeci">_define_variadic&lt; _uvptr, typelist&lt; Ts... &gt; &gt; uvptr</div><div class="ttdef"><b>Definition:</b> uvptr.h:210</div></div>
</div><!-- fragment --><p> Note that the <code>uvptr</code> can accept forward declared struct in friendly manner. Similar (bot not same) to <code>std::make_unique</code>, we have a friendly function to build the unique variants: <code>uwrap</code></p>
<div class="fragment"><div class="line">uvptr&lt;std::string, int&gt; p = uwrap(std::string{<span class="stringliteral">&quot;wololo&quot;</span>});</div>
</div><!-- fragment --><p> Note that signature of uwrap is <code>uvref&lt;T&gt; uwrap(T item)</code>, this works as we allow natural conversion of <code>uvref</code> to <code>uvptr</code>, but not the other way around.</p>
<p >WARNING: <code>uvref</code> is movable object, once moved-from, it is put into <code>null</code> state - something not possible otherwise. It shall not be used in this state in any matter except to be assigned-to.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Access API</h1>
<p >Given that we do have a <code>vptr</code>, how to access it? All variants share the same approach to API, so the name of methods are the same. All have <code>visit</code> method. <code>uvptr</code> and <code>uvref</code> also has <code>take</code>.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Visit</h2>
<p ><code>visit</code> recreates approach similar to <code>std::visit</code>, except that we allow multiple callables instead of multiple variadics, note that we can handle returning from callables: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo( <a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref</a>&lt; std::vector&lt; std::string &gt;, std::list&lt; std::string &gt; &gt; r )</div>
<div class="line">{</div>
<div class="line">        std::string&amp; front = r.visit(</div>
<div class="line">            [&amp;]( std::vector&lt; std::string &gt;&amp; v ) -&gt; std::string&amp; {</div>
<div class="line">                    <span class="keywordflow">return</span> v.front();</div>
<div class="line">            },</div>
<div class="line">            [&amp;]( std::list&lt; std::string &gt;&amp; l ) -&gt; std::string&amp; {</div>
<div class="line">                    <span class="keywordflow">return</span> l.front();</div>
<div class="line">            } );</div>
<div class="line">}</div>
</div><!-- fragment --><p> In case of pointers, we opted to introduce empty branch for cases when it is null. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_typedef" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr&lt;a_t, b_t&gt;</a> r)</div>
<div class="line">{</div>
<div class="line">    r.visit([&amp;](<a class="code hl_struct" href="structvari_1_1empty__t.html">vari::empty_t</a>){},</div>
<div class="line">            [&amp;](a_t&amp;){},</div>
<div class="line">            [&amp;](b_t&amp;){});</div>
<div class="line">}</div>
<div class="ttc" id="astructvari_1_1empty__t_html"><div class="ttname"><a href="structvari_1_1empty__t.html">vari::empty_t</a></div><div class="ttdef"><b>Definition:</b> vptr.h:33</div></div>
</div><!-- fragment --><p >Variadic references are constructible with references - all of the possible types: </p><div class="fragment"><div class="line">a_t a;</div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;a_t, b_t&gt;</a> r = a;</div>
</div><!-- fragment --><p> However, this also means that we can combine this with visit - the callable can handle multiple types: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_typedef" href="namespacevari.html#ad82d68f165b27cedcbdf385779eacb69">vari::uvptr&lt;a_t, b_t&gt;</a> r)</div>
<div class="line">{</div>
<div class="line">    r.visit([&amp;](<a class="code hl_struct" href="structvari_1_1empty__t.html">vari::empty_t</a>){},</div>
<div class="line">            [&amp;](<a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;a_t, b_t&gt;</a>){});</div>
<div class="line">}</div>
</div><!-- fragment --><p> Or we can mix both approaches:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_typedef" href="namespacevari.html#ad82d68f165b27cedcbdf385779eacb69">vari::uvptr&lt;a_t, b_t, c_t&gt;</a> r)</div>
<div class="line">{</div>
<div class="line">    r.visit([&amp;](<a class="code hl_struct" href="structvari_1_1empty__t.html">vari::empty_t</a>){},</div>
<div class="line">            [&amp;](a_t&amp;){},</div>
<div class="line">            [&amp;](<a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;b_t, c_t&gt;</a>){});</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md5"></a>
Take</h2>
<p ><code>uvref</code> and <code>uvptr</code> retain ownership of referenced items, <code>take</code> allows stealing the ownership from the owner: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_typedef" href="namespacevari.html#a53e8ed5b1956a1a8da2dd92ccd1249c9">vari::uvref&lt;a_t, b_t&gt;</a> r)</div>
<div class="line">{</div>
<div class="line">    std::move(r).take([&amp;](<a class="code hl_typedef" href="namespacevari.html#a53e8ed5b1956a1a8da2dd92ccd1249c9">vari::uvref&lt;a_t&gt;</a>){},</div>
<div class="line">                      [&amp;](<a class="code hl_typedef" href="namespacevari.html#a53e8ed5b1956a1a8da2dd92ccd1249c9">vari::uvref&lt;b_t&gt;</a>){});</div>
<div class="line">}</div>
<div class="ttc" id="anamespacevari_html_a53e8ed5b1956a1a8da2dd92ccd1249c9"><div class="ttname"><a href="namespacevari.html#a53e8ed5b1956a1a8da2dd92ccd1249c9">vari::uvref</a></div><div class="ttdeci">_define_variadic&lt; _uvref, typelist&lt; Ts... &gt; &gt; uvref</div><div class="ttdef"><b>Definition:</b> uvref.h:152</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
Concepts checks</h2>
<p >Access methods are subjected to same sanity checking of the set of callbacks: For each type in the set, one and only one callbacks can be called.</p>
<p >That is, following would fail to compile due to concept check: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_typedef" href="namespacevari.html#a53e8ed5b1956a1a8da2dd92ccd1249c9">vari::uvref&lt;a_t, b_t&gt;</a> r)</div>
<div class="line">{</div>
<div class="line">    r.visit([&amp;](a_t&amp;){},</div>
<div class="line">            [&amp;](a_t&amp;){}, <span class="comment">// &lt;&lt; second overload matching a_t</span></div>
<div class="line">            [&amp;](b_t&amp;){});</div>
<div class="line">}</div>
</div><!-- fragment --><p >Keep in mind, that this also affects templated arguments: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_typedef" href="namespacevari.html#a53e8ed5b1956a1a8da2dd92ccd1249c9">vari::uvref&lt;a_t, b_t&gt;</a> r)</div>
<div class="line">{</div>
<div class="line">    r.visit([&amp;](a_t&amp;){},</div>
<div class="line">            [&amp;](<span class="keyword">auto</span>&amp;){}); <span class="comment">// &lt;&lt; second overload matching a_t, but single for b_t</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md7"></a>
Single-type extension</h1>
<p >To make work with variants a bit more convenient, all allow direct access to pointed-to type in case it is single type in the type-list: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>boo_t{</div>
<div class="line">    <span class="keywordtype">int</span> val;</div>
<div class="line">};</div>
<div class="line">boo_t b;</div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr&lt;boo_t&gt;</a> p{b};</div>
<div class="line"> </div>
<div class="line">p-&gt;val = 42;</div>
</div><!-- fragment --><p >That is, in case there is only one type allowed, the signature of common methods is: <code>T* vptr&lt;T&gt;::operator()</code> This makes <code>take</code> API calls much more convenient to use.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Sub-typing</h1>
<p >All variadic types support sub-typing - any variadic type can be converted to a type representing superset of types: </p><div class="fragment"><div class="line">a_t a;</div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;a_t&gt;</a> p{a};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// allowed as {a_t, b_t} is superset of {a_t}</span></div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;a_t, b_t&gt;</a> p2 = p;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// not allowed, as {a_t} is not superset of {a_t, b_t}</span></div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;a_t&gt;</a> p3 = p2;</div>
</div><!-- fragment --><p >There are multiple ways this bring in a lot of convenience, want to have type-coherency? </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacevari.html#a53e8ed5b1956a1a8da2dd92ccd1249c9">vari::uvref&lt;a_t&gt;</a> gen_a();</div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#a53e8ed5b1956a1a8da2dd92ccd1249c9">vari::uvref&lt;b_t&gt;</a> gen_b();</div>
<div class="line"> </div>
<div class="line">std::vector&lt;vari::uvptr&lt;a_t, b_t&gt;&gt; data = {gen_a(), gen_b(), <span class="keyword">nullptr</span>};</div>
</div><!-- fragment --><p >This also interacts well with <code>take</code>: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>c_t;</div>
<div class="line"><span class="keyword">struct </span>d_t;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_typedef" href="namespacevari.html#ad82d68f165b27cedcbdf385779eacb69">vari::uvptr&lt;a_t, b_t, c_t, d_t&gt;</a> p)</div>
<div class="line">{</div>
<div class="line">    p.take([&amp;](<a class="code hl_struct" href="structvari_1_1empty__t.html">vari::empty_t</a>){},</div>
<div class="line">           [&amp;](<a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;a_t, b_t&gt;</a>){},</div>
<div class="line">           [&amp;](<a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;c_t, d_t&gt;</a>){});</div>
<div class="line">}</div>
</div><!-- fragment --><p> The way we can imagine this is: <code>p</code> can represent set of 4 types, <code>take</code> splits that into four unique references, each representing one type, <em>sub-typing</em> allows merging these references together - into two subsets, each made of two types.</p>
<p >Note: As a side-effect of this, <code>vptr&lt;a_t, b_t&gt;</code> is naturally convertible to <code>vptr&lt;b_t, a_t&gt;</code></p>
<h1><a class="anchor" id="autotoc_md9"></a>
Type-sets</h1>
<p >To bring in even more convenience and capability, the template argument list of variadics is capable of flattening and filtering the types for uniqueness. (Note that to implement this we opted for aliasing, for example: <code><a class="el" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr</a></code> is actually alias to <code><a class="el" href="classvari_1_1__vptr.html">vari::_vptr</a></code>)</p>
<p >Given the following type sets: </p><div class="fragment"><div class="line"><span class="keyword">using </span>set_a = <a class="code hl_struct" href="structvari_1_1typelist.html">vari::typelist&lt;a_t, b_t&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>set_b = <a class="code hl_struct" href="structvari_1_1typelist.html">vari::typelist&lt;c_t, d_t&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>set_s = <a class="code hl_struct" href="structvari_1_1typelist.html">vari::typelist&lt;set_a, set_b, d_t&gt;</a>;</div>
<div class="ttc" id="astructvari_1_1typelist_html"><div class="ttname"><a href="structvari_1_1typelist.html">vari::typelist</a></div><div class="ttdef"><b>Definition:</b> typelist.h:30</div></div>
</div><!-- fragment --><p> The pointer <code>vptr&lt;set_s&gt;</code> actually resolves to equivalent of <code>vptr&lt;a_t, b_t, c_t, d_t&gt;</code>. The flatenning/filtering mechanism only resolves <code><a class="el" href="structvari_1_1typelist.html">vari::typelist</a></code>, that means that <code>void&lt;std::tuple&lt;a_t,b_t&gt;&gt;</code> would not be resolved to different form.</p>
<p >Why? well, suddenly one can express complex data structures. Note that the typelists also interact well with sub-typing: </p><div class="fragment"><div class="line"><span class="keyword">using </span>simple_types = <a class="code hl_struct" href="structvari_1_1typelist.html">vari::typelist&lt;std::string, int, bool&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>complex_types = <a class="code hl_struct" href="structvari_1_1typelist.html">vari::typelist&lt;array_t, object_t&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>json_types = <a class="code hl_struct" href="structvari_1_1typelist.html">vari::typelist&lt;simple_types, complex_types&gt;</a>;</div>
<div class="line"> </div>
<div class="line">std::string simple_to_str(<a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;simple_types&gt;</a> p);</div>
<div class="line"> </div>
<div class="line">std::string to_str(<a class="code hl_typedef" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr&lt;json_types&gt;</a> p)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>R = std::string;</div>
<div class="line">    <span class="keywordflow">return</span> p.visit([&amp;](<a class="code hl_struct" href="structvari_1_1empty__t.html">vari::empty_t</a>) -&gt; R { <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>; },</div>
<div class="line">                   [&amp;](<a class="code hl_typedef" href="namespacevari.html#a0b711b10138e06f9d5b455ff55c663d0">vari::vref&lt;simple_types&gt;</a> pp) -&gt; R { <span class="keywordflow">return</span> simple_to_str(p); },</div>
<div class="line">                   [&amp;](array_t&amp; pp) -&gt; R { <span class="comment">/* impl */</span> },</div>
<div class="line">                   [&amp;](object_t&amp; pp) -&gt; R { <span class="comment">/* impl */</span> });</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md10"></a>
Lvalue conversion from unique</h1>
<p >To give this even more convenience, we also allow conversion of <code>uvptr</code> and <code>uvref</code> to non-unique variants if and only if the expression is lvalue reference:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_typedef" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr&lt;a_t, b_t&gt;</a>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#ad82d68f165b27cedcbdf385779eacb69">vari::uvptr&lt;a_t&gt;</a> p;</div>
<div class="line">foo(p); <span class="comment">// allowed, `p` is lvalue</span></div>
<div class="line"> </div>
<div class="line">foo(<a class="code hl_typedef" href="namespacevari.html#ad82d68f165b27cedcbdf385779eacb69">vari::uvptr&lt;a_t&gt;</a>{}) <span class="comment">// forbidden, rvalue used</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md11"></a>
Const</h1>
<p >All variadic types support conversion from non-const version to const version: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_typedef" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr&lt;const a_t, const b_t&gt;</a>)</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr&lt;a_t, b_t&gt;</a> p;</div>
<div class="line">foo(p);</div>
</div><!-- fragment --><p ><code>const</code> is also properly propagated during typelist operations: </p><div class="fragment"><div class="line"><span class="keyword">using </span>set_a = <a class="code hl_struct" href="structvari_1_1typelist.html">vari::typelist&lt;a_t, b_t&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>vp_a = <a class="code hl_typedef" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr&lt;const set_a&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>vp_b = <a class="code hl_typedef" href="namespacevari.html#a50c11a69a9d782e1ccaa6ebd7be73725">vari::vptr&lt;const a_t, const b_t&gt;</a>;</div>
</div><!-- fragment --><p> Both types <code>vp_a</code> and <code>vp_b</code> are equal.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Credits</h1>
<p >Credits for the idea for this should go to <code>avakar</code>, live long and prosper. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
